<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="pl" xml:lang="pl"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.203">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Automatyczna analiza obrazu - 8&nbsp; Filtry morfologiczne</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./fourier.html" rel="next">
<link href="./edge.html" rel="prev">
<link href="./cover.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "Brak wyników",
    "search-matching-documents-text": "dopasowane dokumenty",
    "search-copy-link-title": "Kopiuj link do wyszukiwania",
    "search-hide-matches-text": "Ukryj dodatkowe dopasowania",
    "search-more-match-text": "więcej dopasowań w tym dokumencie",
    "search-more-matches-text": "więcej dopasowań w tym dokumencie",
    "search-clear-button-title": "Wyczyść",
    "search-detached-cancel-button-title": "Anuluj",
    "search-submit-button-title": "Zatwierdź"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./morpho.html">&lt;span class='chapter-number'&gt;8&lt;/span&gt;&nbsp; &lt;span class='chapter-title'&gt;Filtry morfologiczne&lt;/span&gt;</a></li></ol></nav>
      <a class="flex-grow-1" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
      </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      <img src="./images/logo.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Automatyczna analiza obrazu</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://twitter.com" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-twitter"></i></a>
    <a href="https://github.com/dax44/ComputerVision/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="https://twitter.com/intent/tweet?url=|url|" title="Twitter" class="quarto-navigation-tool px-1" aria-label="Twitter"><i class="bi bi-twitter"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Wstęp</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Wprowadzenie</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./history.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Historia wizji komputerowej</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./digt_img.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Obrazy cyfrowe</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./transformations.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Transformacje geometryczne</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./point_trans.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Transformacje punktowe</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./filters.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Filtry</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./edge.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Wykrywanie krawędzi i konturów</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./morpho.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Filtry morfologiczne</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./fourier.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Transformata Fouriera</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">Bibliografia</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Spis treści</h2>
   
  <ul>
  <li><a href="#identyfikacja-sąsiadów" id="toc-identyfikacja-sąsiadów" class="nav-link active" data-scroll-target="#identyfikacja-sąsiadów"><span class="toc-section-number">8.1</span>  Identyfikacja sąsiadów</a></li>
  <li><a href="#podstawowe-operacje-morfologiczne" id="toc-podstawowe-operacje-morfologiczne" class="nav-link" data-scroll-target="#podstawowe-operacje-morfologiczne"><span class="toc-section-number">8.2</span>  Podstawowe operacje morfologiczne</a>
  <ul class="collapse">
  <li><a href="#element-strukturyzujący" id="toc-element-strukturyzujący" class="nav-link" data-scroll-target="#element-strukturyzujący"><span class="toc-section-number">8.2.1</span>  Element strukturyzujący</a></li>
  </ul></li>
  <li><a href="#operacje-morfologiczne-w-skali-szarości-i-na-obrazach-kolorowych" id="toc-operacje-morfologiczne-w-skali-szarości-i-na-obrazach-kolorowych" class="nav-link" data-scroll-target="#operacje-morfologiczne-w-skali-szarości-i-na-obrazach-kolorowych"><span class="toc-section-number">8.3</span>  Operacje morfologiczne w skali szarości i na obrazach kolorowych</a>
  <ul class="collapse">
  <li><a href="#element-strukturyzujący-1" id="toc-element-strukturyzujący-1" class="nav-link" data-scroll-target="#element-strukturyzujący-1"><span class="toc-section-number">8.3.1</span>  Element strukturyzujący</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/dax44/ComputerVision/issues/new" class="toc-action">Zgłoś problem</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Filtry morfologiczne</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>Omawiając filtr medianowy , zauważyliśmy, że ten typ filtra może w pewien sposób zmieniać struktury obrazów dwuwymiarowych. <a href="#fig-med1">Rysunek&nbsp;<span>8.1</span></a> ilustruje, w jaki sposób zaokrąglane są narożniki, wypełniane otwory o określonym rozmiarze oraz usuwane małe struktury, takie jak pojedyncze kropki lub cienkie linie. Filtr medianowy reaguje więc wybiórczo na lokalny kształt struktur obrazu, co jest właściwością, która może być przydatna do innych celów, jeśli można ją stosować nie tylko losowo, ale w sposób kontrolowany. Zmienianie lokalnej struktury w przewidywalny sposób jest właśnie tym, co potrafią robić filtry “morfologiczne”, na których skupiamy się w tym rozdziale.</p>
<div id="fig-med1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2023-02-21 o 19.37.04.png" class="img-fluid figure-img" width="600"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;8.1: Zastosowanie filtra medianowego. (a) oryginalny obraz, (b) obraz z filtrem 3x3, (c) obraz z filtrem 5x5</figcaption><p></p>
</figure>
</div>
<p>W swojej pierwotnej formie filtry morfologiczne są ukierunkowane na obrazy binarne, obrazy o tylko dwóch możliwych wartościach pikseli, odpowiednio 0 i 1 lub czarny i biały. Obrazy binarne spotykane są w wielu miejscach, w szczególności w druku cyfrowym, transmisji dokumentów (fax) i przechowywaniu danych, czy też jako maski selekcyjne w edycji obrazów i filmów. Obrazy binarne można uzyskać z obrazów w skali szarości poprzez proste progowanie z użyciem globalnej lub lokalnie zmiennej wartości progowej. Piksele binarne o wartościach 1 i 0 oznaczamy odpowiednio jako piksele pierwszego planu i tła. W większości poniższych przykładów piksele pierwszego planu są przedstawione w kolorze czarnym, a piksele tła w kolorze białym, tak jak to się dzieje w druku.</p>
<p>Pod koniec tego rozdziału przekonamy się, że filtry morfologiczne mają zastosowanie nie tylko do obrazów binarnych, ale także do obrazów w skali szarości, a nawet kolorowych, choć operacje te różnią się znacznie od ich binarnych odpowiedników.</p>
<p>Naszym punktem wyjścia była obserwacja, że prosty filtr medianowy o wymiarach 3×3 pikseli może zaokrąglić większe struktury obrazu i usunąć mniejsze, takie jak punkty i cienkie linie, w obrazie binarnym. Może to być przydatne do eliminacji struktur, które są poniżej pewnego rozmiaru (np. do oczyszczenia obrazu z szumów lub zanieczyszczeń). Ale jak możemy kontrolować rozmiar i ewentualnie kształt struktur dotkniętych taką operacją?</p>
<p>Chociaż jego efekty strukturalne mogą być interesujące, pomijamy w tym momencie filtr medianowy i zaczynamy to zadanie od początku. Załóżmy, że chcemy usunąć małe struktury z obrazu binarnego, nie zmieniając znacząco pozostałych większych struktur. Pomysł na realizacje tego zadania może być następujący:</p>
<ol type="1">
<li>Najpierw wszystkie struktury w obrazie są iteracyjnie “zmniejszane” (lub “kurczenie”) przez odklejanie warstwy o określonej grubości wokół granic.</li>
<li>Kurczenie usuwa krok po kroku mniejsze struktury i pozostają tylko większe.</li>
<li>Pozostałe struktury są następnie powiększane o taką samą ilość.</li>
<li>W końcu większe regiony powinny powrócić do mniej więcej swoich pierwotnych kształtów, podczas gdy mniejsze regiony zniknęły z obrazu.</li>
</ol>
<div id="fig-shrunk" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2023-02-21 o 19.50.06.png" class="img-fluid figure-img" width="600"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;8.2: “Kurczenie” obrazu. (a) oryginał, (b) obraz z zidentyfikowanymi pikselami sąsiadującymi z tłem, (c) obraz po usunięciu pikseli zidentyfikowanych jako sąsiadujące z tłem</figcaption><p></p>
</figure>
</div>
<p>Potrzebujemy do tego jedynie dwóch rodzajów operacji. ” Kurczenie” oznacza usunięcie warstwy pikseli z regionu pierwszoplanowego wokół wszystkich jego granic na tle (<a href="#fig-shrunk">Rysunek&nbsp;<span>8.2</span></a>). Z drugiej strony, “rośnięcie”, dodaje warstwę pikseli wokół granicy regionu pierwszoplanowego (<a href="#fig-grow">Rysunek&nbsp;<span>8.3</span></a>).</p>
<div id="fig-grow" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2023-02-21 o 19.50.15.png" class="img-fluid figure-img" width="600"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;8.3: “Rośnięcie” obrazu. (a) oryginał, (b) identyfikacja pikseli sąsiadujących z tłem, (c) dodanie pikseli sąsiadujących z tłem</figcaption><p></p>
</figure>
</div>
<section id="identyfikacja-sąsiadów" class="level2" data-number="8.1">
<h2 data-number="8.1" class="anchored" data-anchor-id="identyfikacja-sąsiadów"><span class="header-section-number">8.1</span> Identyfikacja sąsiadów</h2>
<p>W przypadku prostokątnych siatek pikseli powszechnie stosowane są dwie definicje “sąsiedztwa” ():</p>
<ul>
<li>cztery piksele sąsiadujące z danym pikselem w kierunku poziomym i pionowym;</li>
<li>osiem sąsiadujących pikseli z analizowanym.</li>
</ul>
<div id="fig-neigh1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2023-02-21 o 19.59.25.png" class="img-fluid figure-img" width="400"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;8.4: Definicje sąsiedztwa</figcaption><p></p>
</figure>
</div>
</section>
<section id="podstawowe-operacje-morfologiczne" class="level2" data-number="8.2">
<h2 data-number="8.2" class="anchored" data-anchor-id="podstawowe-operacje-morfologiczne"><span class="header-section-number">8.2</span> Podstawowe operacje morfologiczne</h2>
<p>Zmniejszanie i zwiększanie to rzeczywiście dwie najbardziej podstawowe operacje morfologiczne, które są określane odpowiednio jako “erozja” (ang. <em>erosion</em>) i “dylatacja” (ang. <em>dilation</em>). Operacje te są jednak znacznie bardziej ogólne niż zilustrowane w przykładzie. Wykraczają one daleko poza usuwanie lub dołączanie warstw pojedynczych pikseli i - w połączeniu - mogą wykonywać znacznie bardziej złożone operacje.</p>
<section id="element-strukturyzujący" class="level3" data-number="8.2.1">
<h3 data-number="8.2.1" class="anchored" data-anchor-id="element-strukturyzujący"><span class="header-section-number">8.2.1</span> Element strukturyzujący</h3>
<p>Podobnie jak w przypadku macierzy współczynników filtru liniowego, właściwości filtru morfologicznego są określone przez elementy macierzy zwanej “elementem strukturyzującym”. W morfologii binarnej element strukturyzujący (podobnie jak sam obraz) zawiera tylko wartości 0, a “gorący punkt” (ang. <em>hot spot</em>) wyznacza początek układu współrzędnych <span class="math inline">\(H\)</span> (<a href="#fig-hot-spot">Rysunek&nbsp;<span>8.5</span></a>). Przy czym, hot spot nie musi znajdować się w środku elementu strukturyzującego, ani jego wartość nie musi być równa 1.</p>
<div id="fig-hot-spot" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2023-02-21 o 20.09.20.png" class="img-fluid figure-img" width="400"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;8.5: Element strukturyzujący</figcaption><p></p>
</figure>
</div>
<section id="zbiór-punktowy" class="level4" data-number="8.2.1.1">
<h4 data-number="8.2.1.1" class="anchored" data-anchor-id="zbiór-punktowy"><span class="header-section-number">8.2.1.1</span> Zbiór punktowy</h4>
<p>Dla formalnej specyfikacji operacji morfologicznych pomocne jest czasem opisanie obrazów binarnych jako zbiorów punktów o współrzędnych 2D. Dla obrazu binarnego <span class="math inline">\(I(u, v) \in \{0, 1\}\)</span>, odpowiadający zbiór punktów <span class="math inline">\(\mathcal{Q}_I\)</span> składa się z par współrzędnych <span class="math inline">\(p = (u, v)\)</span> wszystkich pikseli pierwszego planu,</p>
<p><span id="eq-fore1"><span class="math display">\[
\mathcal{Q}_I =\{p\vert I(p)=1\}.
\tag{8.1}\]</span></span></p>
<p>Oczywiście, jak pokazano na rys, nie tylko obraz binarny <span class="math inline">\(I\)</span>, ale również element strukturyzujący <span class="math inline">\(H\)</span> może być opisany jako zbiór punktów.</p>
<div id="fig-point1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2023-02-21 o 20.09.43.png" class="img-fluid figure-img" width="400"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;8.6: Obraz binarny z elementem strukturyzującym</figcaption><p></p>
</figure>
</div>
<p>Dzięki temu, że opisujemy je jako zbiory punktów, podstawowe operacje na obrazach binarnych można również wyrazić jako proste operacje na zbiorach. Na przykład, odwrócenie obrazu binarnego <span class="math inline">\(I \rightarrow \bar{I}\)</span> (czyli zamiana pierwszego planu i tła) jest równoważne zbudowaniu zbioru dopełniającego</p>
<p><span id="eq-fore2"><span class="math display">\[
\mathcal{Q}_{\bar{I}}=\bar{\mathcal{Q}}_I=\{p\in \mathbb{Z}^2\vert p\in \mathcal{Q}_I\}.
\tag{8.2}\]</span></span></p>
<p>Łącząc dwa obrazy binarne <span class="math inline">\(I_1\)</span> i <span class="math inline">\(I_2\)</span> za pomocą operacji OR między odpowiadającymi im pikselami, otrzymany zbiór punktów jest unią indywidualnych zbiorów punktów <span class="math inline">\(Q_{I_1}\)</span> i <span class="math inline">\(Q_{I_2}\)</span>. Ponieważ zbiór punktów <span class="math inline">\(Q_I\)</span> jest tylko alternatywną reprezentacją obrazu binarnego <span class="math inline">\(I\)</span> (tzn. <span class="math inline">\(I = Q_I\)</span>), to w dalszej części będziemy używać synonimicznie obu notacji: obrazu i zbioru.</p>
</section>
<section id="dylatacja" class="level4" data-number="8.2.1.2">
<h4 data-number="8.2.1.2" class="anchored" data-anchor-id="dylatacja"><span class="header-section-number">8.2.1.2</span> Dylatacja</h4>
<p>Dylatacja jest operacją morfologiczną, która odpowiada naszemu intuicyjnemu pojęciu “wzrastania”, omówionemu już wcześniej. Jako operacja na zbiorach, jest ona zdefiniowana jako</p>
<p><span id="eq-dil1"><span class="math display">\[
I\oplus H= \{(p+q)| p\in I, q\in H \}.
\tag{8.3}\]</span></span></p>
<div id="fig-dil1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2023-02-21 o 20.09.59.png" class="img-fluid figure-img" width="400"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;8.7: Przykład dylatacji</figcaption><p></p>
</figure>
</div>
<p>Tak więc zbiór punktów powstały w wyniku dylatacji jest sumą (wektorową) wszystkich możliwych par punktów współrzędnych z oryginalnych zbiorów <span class="math inline">\(I\)</span> i <span class="math inline">\(H\)</span>, co ilustruje prosty przykład na <a href="#fig-dil1">Rysunek&nbsp;<span>8.7</span></a>. Alternatywnie można postrzegać dylatację jako powielenie elementu struktury <span class="math inline">\(H\)</span> na każdy piksel pierwszego planu obrazu <span class="math inline">\(I\)</span> lub, odwrotnie, powielenie obrazu <span class="math inline">\(I\)</span> na każdy element pierwszego planu <span class="math inline">\(H\)</span>.</p>
</section>
<section id="erozja" class="level4" data-number="8.2.1.3">
<h4 data-number="8.2.1.3" class="anchored" data-anchor-id="erozja"><span class="header-section-number">8.2.1.3</span> Erozja</h4>
<p>Quasi-odwrotnością dylatacji jest operacja erozji, ponownie zdefiniowana w notacji zbiorów jako</p>
<p><span id="eq-eros1"><span class="math display">\[
I\ominus H= \{p\in \mathbb{Z}^2| (p+q)\in I, q\in H \}.
\tag{8.4}\]</span></span></p>
<p>Operację tę można zinterpretować następująco. Pozycja <span class="math inline">\(p\)</span> jest zawarta w wyniku <span class="math inline">\(I \ominus H\)</span> wtedy (i tylko wtedy), gdy element strukturyzujący <span class="math inline">\(H\)</span> - po umieszczeniu w tej pozycji <span class="math inline">\(p\)</span> - jest w całości zawarty w pikselach pierwszego planu oryginalnego obrazu. <a href="#fig-eros1">Rysunek&nbsp;<span>8.8</span></a> przedstawia przykład erozji.</p>
<div id="fig-eros1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2023-02-21 o 20.10.14.png" class="img-fluid figure-img" width="400"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;8.8: Przykład erozji</figcaption><p></p>
</figure>
</div>
<p>Filtr morfologiczny jest jednoznacznie określony przez (a) rodzaj operacji i (b) zawartość elementu strukturyzującego. Odpowiedni rozmiar i kształt elementu strukturyzującego zależy od zastosowania, rozdzielczości obrazu itp. W praktyce często stosuje się elementy strukturyzujące o quasi-kolistym kształcie.</p>
<div id="fig-eros-dil" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2023-02-21 o 20.51.53.png" class="img-fluid figure-img" width="600"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;8.9: Wyniki dylatacji i erozji z różnymi promieniami</figcaption><p></p>
</figure>
</div>
<p>Dylatacja z wykorzystaniem okrągłego (dyskowego) elementu strukturyzującego o promieniu <span class="math inline">\(r\)</span> powoduje dodanie warstwy o szerokości <span class="math inline">\(r\)</span> do każdej struktury pierwszoplanowej w obrazie. I odwrotnie, erozja z tym elementem strukturyzującym usuwa warstwy o tej samej szerokości. Na <a href="#fig-eros-dil">Rysunek&nbsp;<span>8.9</span></a> przedstawiono wyniki dylatacji i erozji z użyciem dyskowych elementów strukturyzujących o różnych średnicach, zastosowanych do oryginalnego obrazu z rysunku.</p>
<p>Wyniki dylatacji i erozji dla różnych innych elementów strukturyzujących pokazano na <a href="#fig-eros-dil2">Rysunek&nbsp;<span>8.10</span></a>.</p>
<div id="fig-eros-dil2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2023-02-21 o 20.55.14.png" class="img-fluid figure-img" width="600"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;8.10: Wyniki dylatacji i erozji z różnymi filtrami</figcaption><p></p>
</figure>
</div>
</section>
<section id="otwarcie-i-zamknięcie" class="level4" data-number="8.2.1.4">
<h4 data-number="8.2.1.4" class="anchored" data-anchor-id="otwarcie-i-zamknięcie"><span class="header-section-number">8.2.1.4</span> Otwarcie i zamknięcie</h4>
<p>Złożenia funkcji dylatacji i erozji w odpowiedniej kolejności tworzą nowe transformacje nazywane otwarcie (ang. <em>opening</em>) i zamknięcie (ang. <em>closing</em>)<em>. S</em>ą one prawdopodobnie najczęściej używanymi przekształceniami morfologicznymi.</p>
<p>Otwarcie binarne <span class="math inline">\(I\circ H\)</span> oznacza erozję, po której następuje dylatacja z tym samym elementem strukturyzującym <span class="math inline">\(H\)</span>, czyli</p>
<p><span id="eq-opening"><span class="math display">\[
I\circ H=(I\ominus H)\oplus H.
\tag{8.5}\]</span></span></p>
<p>Głównym efektem otwarcia jest to, że wszystkie struktury pierwszego planu, które są mniejsze niż element strukturyzujący, są eliminowane w pierwszym kroku (erozja). Pozostałe struktury są wygładzane przez dylatację i powiększane w przybliżeniu do ich pierwotnego rozmiaru, jak pokazano na przykładach na <a href="#fig-open-close">Rysunek&nbsp;<span>8.11</span></a>. Ten proces kurczenia się, a następnie wzrostu odpowiada idei eliminacji małych struktur, którą wstępnie naszkicowaliśmy wcześniej.</p>
<div id="fig-open-close" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2023-02-22 o 16.35.22.png" class="img-fluid figure-img" width="400"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;8.11: Przykładowe zastosowania opening i closing</figcaption><p></p>
</figure>
</div>
<p>Gdy odwrócimy kolejność erozji i dylatacji, otrzymaną operację nazywamy domknięciem i oznaczamy <span class="math inline">\(I\bullet H\)</span></p>
<p><span id="eq-closing"><span class="math display">\[
I\bullet H=(I\oplus H)\ominus H.
\tag{8.6}\]</span></span></p>
<p>Zamknięcie usuwa (zamyka) otwory i szczeliny w strukturach pierwszego planu, które są mniejsze niż element strukturyzujący <span class="math inline">\(H\)</span>. Kilka przykładów z typowymi elementami strukturyzującymi w kształcie dysku pokazano na <a href="#fig-open-close">Rysunek&nbsp;<span>8.11</span></a>.</p>
</section>
<section id="przerzedzanie" class="level4" data-number="8.2.1.5">
<h4 data-number="8.2.1.5" class="anchored" data-anchor-id="przerzedzanie"><span class="header-section-number">8.2.1.5</span> Przerzedzanie</h4>
<p>Rozrzedzanie (ang. <em>thininng</em>) zwana też szkieletyzacją (ang. <em>skeletonization</em>) jest powszechną techniką morfologiczną, której celem jest zmniejszenie struktur binarnych do maksymalnej szerokości jednego piksela bez dzielenia ich na wiele części. Osiąga się to poprzez iteracyjną erozję “warunkową”. Jest ona stosowana w lokalnym sąsiedztwie tylko wtedy, gdy pozostaje wystarczająco szeroka struktura i operacja nie powoduje separacji. Wymaga to, aby w zależności od lokalnej struktury obrazu, w każdej pozycji obrazu podejmowana była decyzja, czy można zastosować kolejny krok erozji, czy też nie. Operacja jest kontynuowana do momentu, gdy w obrazie wynikowym nie pojawią się już żadne zmiany. Wynika z tego, że w porównaniu ze zwykłą (“homogeniczną”) morfologią omówioną wcześniej, thinning jest kosztowny obliczeniowo. Częstym zastosowaniem rozrzedzania jest obliczanie “szkieletu” regionu binarnego, np. w celu strukturalnego dopasowania kształtów 2D.</p>
<p>Rozrzedzanie znane jest również pod terminami wykrywanie linii środkowej i transformacji osi środkowej. Istnieje wiele różnych implementacji o zróżnicowanej złożoności i wydajności. Poniżej opisujemy klasyczny algorytm autorstwa <span class="citation" data-cites="zhang1984">Zhang i Suen (<a href="references.html#ref-zhang1984" role="doc-biblioref">1984</a>)</span> oraz jego implementację jako reprezentatywny przykład.</p>
<p>Wejściem do tego algorytmu jest obraz binarny <span class="math inline">\(I\)</span>, w którym piksele pierwszego planu mają wartość 1, a piksele tła wartość 0. Algorytm skanuje obraz i w każdej pozycji <span class="math inline">\((u, v)\)</span> bada sąsiedztwo rozmiaru 3x3 z centralnym elementem <span class="math inline">\(P\)</span> i otaczającymi go wartościami <span class="math inline">\(N = (N_0, N_1, \ldots , N_7)\)</span>.</p>
<p>W celu sklasyfikowania zawartości lokalnego sąsiedztwa <span class="math inline">\(N\)</span> definiujemy najpierw funkcję</p>
<p><span id="eq-bn"><span class="math display">\[
B(N)=N_0+N_1+\dots+N_7=\sum_{i=0}^7N_i,
\tag{8.7}\]</span></span></p>
<p>która zlicza piksele otaczającego tła. Definiujemy również tzw. liczbę łączności, która wyraża ile składowych binarnych jest połączonych poprzez bieżący piksel centralny w pozycji $(u, v)$. Wielkość ta jest równoważna liczbie przejść <span class="math inline">\(1\to 0\)</span> w ciągu <span class="math inline">\((N_0, . . . , N_7, N_0)\)</span>, lub wyrażona w sposób arytmetyczny</p>
<p><span id="eq-cn"><span class="math display">\[
C(N)=\sum_{i=0}^7N_i\cdot [N_i-N_{(i+1) \text{ mod }8}].
\tag{8.8}\]</span></span></p>
<p>Rysunek 9.19 przedstawia kilka wybranych przykładów dla sąsiedztwa <span class="math inline">\(N\)</span> oraz związane z nimi wartości funkcji <span class="math inline">\(B(N)\)</span> i <span class="math inline">\(C(N)\)</span>. Na podstawie powyższych funkcji definiujemy ostatecznie dwa predykaty booleańskie <span class="math inline">\(R_1,R_2\)</span> na sąsiedztwie <span class="math inline">\(N\)</span>.</p>
<div id="fig-thinning" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2023-02-22 o 17.01.13.png" class="img-fluid figure-img" width="400"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;8.12: Przebieg rozrzedzania</figcaption><p></p>
</figure>
</div>
<p>W zależności od wyniku <span class="math inline">\(R_1(N)\)</span> i <span class="math inline">\(R_2(N)\)</span> piksel pierwszego planu na środkowej pozycji <span class="math inline">\(N\)</span> jest albo usuwany (czyli erodowany), albo oznaczany jako nieusuwalny.</p>
<div id="fig-thinning2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2023-02-22 o 17.06.19.png" class="img-fluid figure-img" width="600"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;8.13: Kolejne iteracje rozrzedzania</figcaption><p></p>
</figure>
</div>
<p><a href="#fig-thinning2">Rysunek&nbsp;<span>8.13</span></a> ilustruje efekt rozrzedzania warstwa po warstwie wykonywanego przez kolejne iteracje tej procedury. W każdej iteracji selektywnie usuwana jest tylko jedna “warstwa” pikseli pierwszego planu.</p>
</section>
</section>
</section>
<section id="operacje-morfologiczne-w-skali-szarości-i-na-obrazach-kolorowych" class="level2" data-number="8.3">
<h2 data-number="8.3" class="anchored" data-anchor-id="operacje-morfologiczne-w-skali-szarości-i-na-obrazach-kolorowych"><span class="header-section-number">8.3</span> Operacje morfologiczne w skali szarości i na obrazach kolorowych</h2>
<p>Operacje morfologiczne nie ograniczają się do obrazów binarnych, ale dotyczą również obrazów intensywnościowych (w skali szarości). W rzeczywistości, definicja morfologii skali szarości jest uogólnieniem morfologii binarnej, przy czym binarne operatory OR i AND zostały zastąpione przez arytmetyczne operatory MAX i MIN, odpowiednio. W konsekwencji procedury przeznaczone do morfologii w skali szarości mogą również wykonywać morfologię binarną (ale nie odwrotnie). W przypadku obrazów kolorowych, operacje w skali szarości są zwykle stosowane indywidualnie do każdego kanału kolorystycznego.</p>
<section id="element-strukturyzujący-1" class="level3" data-number="8.3.1">
<h3 data-number="8.3.1" class="anchored" data-anchor-id="element-strukturyzujący-1"><span class="header-section-number">8.3.1</span> Element strukturyzujący</h3>
<p>Inaczej niż w schemacie binarnym, elementy strukturyzujące dla morfologii w skali szarości nie są zdefiniowane jako zbiory punktów, lecz jako funkcje rzeczywiste 2D, czyli</p>
<p><span id="eq-el-struk"><span class="math display">\[
H(i,j)\in\mathbb{R}, \quad (i,j)\in\mathbb{Z}^2.
\tag{8.9}\]</span></span></p>
<p>Wartości w <span class="math inline">\(H\)</span> mogą być ujemne lub zerowe. Zauważmy jednak, że w przeciwieństwie do konwolucji liniowej, elementy zerowe w morfologii skali szarości mają na ogół swój udział w wyniku. Element strukturyzujący dla morfologii w skali szarości musi zatem wyraźnie rozróżniać komórki zawierające wartość 0 i komórki puste, na przykład</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2023-02-22 o 17.25.27.png" class="img-fluid figure-img" width="200"></p>
</figure>
</div>
<section id="dylatacja-i-erozja" class="level4" data-number="8.3.1.1">
<h4 data-number="8.3.1.1" class="anchored" data-anchor-id="dylatacja-i-erozja"><span class="header-section-number">8.3.1.1</span> Dylatacja i erozja</h4>
<p>Wynik dylatacji w skali szarości <span class="math inline">\(I\oplus H\)</span> definiujemy jako maksimum wartości w <span class="math inline">\(H\)</span> dodane do wartości bieżącego podobrazu <span class="math inline">\(I\)</span>, czyli</p>
<p><span id="eq-erosion3"><span class="math display">\[
(I\oplus H)(u,v)=\max_{(i,j)\in H}(I(u+i,v+j)+H(i,j)).
\tag{8.10}\]</span></span></p>
<p>Podobnie wynik erozji w skali szarości to minimum różnic</p>
<p><span id="eq-erosion4"><span class="math display">\[
(I\ominus H)(u,v)=\max_{(i,j)\in H}(I(u+i,v+j)-H(i,j)).
\tag{8.11}\]</span></span></p>
<p>Na <a href="#fig-dilatation2">Rysunek&nbsp;<span>8.14</span></a> i <a href="#fig-erosion4">Rysunek&nbsp;<span>8.15</span></a> zademonstrowano na prostym przykładzie podstawowy proces, odpowiednio, dylatacji i erozji w skali szarości.</p>
<div id="fig-dilatation2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2023-02-22 o 17.31.30.png" class="img-fluid figure-img" width="400"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;8.14: Przykład dylatacji w skali szarości</figcaption><p></p>
</figure>
</div>
<div id="fig-erosion4" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2023-02-22 o 17.32.00.png" class="img-fluid figure-img" width="400"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;8.15: Przykład erozji w skali szarości</figcaption><p></p>
</figure>
</div>
</section>
<section id="otwarcie-i-domknięcie" class="level4" data-number="8.3.1.2">
<h4 data-number="8.3.1.2" class="anchored" data-anchor-id="otwarcie-i-domknięcie"><span class="header-section-number">8.3.1.2</span> Otwarcie i domknięcie</h4>
<p>Otwarcie i domknięcie na obrazach w skali szarości definiuje się, identycznie jak w przypadku binarnym, jako operacje złożone z dylatacji i erozji z tym samym elementem strukturyzującym. Kilka przykładów pokazano na rysunku 9.27 dla elementów strukturyzujących w kształcie dysku oraz na rysunku 9.29 dla różnych niestandardowych elementów strukturyzujących. Zauważ, że można uzyskać interesujące efekty, szczególnie w przypadku elementów strukturyzujących przypominających kształtem pędzel lub inne wzory pociągnięć.</p>
<div id="fig-opening3" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2023-02-22 o 17.39.43.png" class="img-fluid figure-img" width="600"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;8.16: Przykład otwarcia i zamknięcia z elementem strukturyzującym w kształcie dysku</figcaption><p></p>
</figure>
</div>
<div id="fig-opening4" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2023-02-22 o 17.45.12.png" class="img-fluid figure-img" width="600"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;8.17: Przykłady otwarcia i domknięcia z zastosowaniem różnych kształtów elementu strukturyzującego</figcaption><p></p>
</figure>
</div>


<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography" style="display: none">
<div id="ref-zhang1984" class="csl-entry" role="doc-biblioentry">
Zhang, T. Y., i C. Y. Suen. 1984. <span>„A Fast Parallel Algorithm for Thinning Digital Patterns”</span>. <em>Communications of the ACM</em> 27 (3): 236–39. <a href="https://doi.org/10.1145/357994.358023">https://doi.org/10.1145/357994.358023</a>.
</div>
</div>
</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Skopiowano!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Skopiowano!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./edge.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Wykrywanie krawędzi i konturów</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./fourier.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Transformata Fouriera</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">Automatyczna analiza obrazu, Dariusz Majerek</div>   
    <div class="nav-footer-right">Książka została napisana w <a href="https://quarto.org/">Quarto</a></div>
  </div>
</footer>



</body></html>